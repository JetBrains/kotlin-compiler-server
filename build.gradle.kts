import org.gradle.kotlin.dsl.support.serviceOf
import org.jetbrains.kotlin.gradle.targets.js.nodejs.NodeJsPlugin.Companion.kotlinNodeJsEnvSpec
import org.jetbrains.kotlin.gradle.targets.js.nodejs.NodeJsRootPlugin
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
import org.springframework.boot.gradle.tasks.bundling.BootJar

val policy: String by System.getProperties()

group = "com.compiler.server"
version = "${libs.versions.kotlin.get()}-SNAPSHOT"

val propertyFile = "application.properties"

plugins {
    id("base-spring-boot-conventions")
}

apply<NodeJsRootPlugin>()

allprojects {
    afterEvaluate {
        dependencies {
            dependencies {
                implementation(libs.jackson.module.kotlin)
            }
        }
    }
}

val resourceDependency: Configuration by configurations.creating {
    isCanBeResolved = true
    isCanBeConsumed = false
}

dependencies {
    annotationProcessor(libs.spring.context.indexer)
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    implementation(libs.aws.springboot.container)
    implementation(libs.springdoc.webmvc)
    implementation(libs.gson)
    implementation(libs.kotlinx.serialization.json)
    implementation(libs.kotlin.compiler.arguments.description)
    implementation(libs.junit)
    implementation(libs.logback.logstash.encoder)
    implementation(libs.kotlin.reflect)
    implementation(libs.kotlin.stdlib)
    implementation(libs.kotlin.script.runtime)
    implementation(libs.kotlin.build.tools.api)
    implementation(libs.kotlin.build.tools.impl)
    implementation(libs.kotlin.compiler.embeddable)
    implementation(libs.kotlin.tooling.core)
    implementation(project(":executors", configuration = "default"))
    implementation(project(":common", configuration = "default"))
    implementation(project(":dependencies"))

    testImplementation(libs.kotlin.test)
    testImplementation(libs.kotlinx.coroutines.test)

    resourceDependency(libs.skiko.js.wasm.runtime)
}

fun buildPropertyFile() {
    rootDir.resolve("src/main/resources/${propertyFile}").apply {
        println("Generate properties into $absolutePath")
        parentFile.mkdirs()
        writeText(generateProperties())
    }
}

fun generateProperties(prefix: String = "") = """
    # this file is autogenerated by build.gradle.kts
    server.error.include-message=always
    server.error.include-binding-errors=always
    kotlin.version=${kotlinVersion}
    policy.file=${prefix + policy}
    libraries.folder.jvm=${prefix + libJVM}
    libraries.folder.js=${prefix + libJS}
    libraries.folder.wasm=${prefix + libWasm}
    libraries.folder.compose-wasm=${prefix + libComposeWasm}
    libraries.folder.compose-wasm-compiler-plugins=${prefix + libComposeWasmCompilerPlugins}
    libraries.folder.compiler-plugins=${prefix + compilerPluginsForJVM}
    spring.mvc.pathmatch.matching-strategy=ant_path_matcher
    server.compression.enabled=true
    server.compression.mime-types=application/json,text/javascript,application/wasm
    springdoc.swagger-ui.path: /api-docs/swagger-ui.html
""".trimIndent()

tasks.withType<KotlinCompile> {
    dependsOn(":executors:jar")
    buildPropertyFile()
}
println("Using Kotlin compiler ${libs.versions.kotlin.get()}")

tasks.withType<BootJar> {
    requiresUnpack("**/kotlin-*.jar")
    requiresUnpack("**/kotlinx-*.jar")
}

val buildLambda by tasks.creating(Zip::class) {
    val propertyFile = propertyFile
    val propertyFileContent = generateProperties("/var/task/")

    from(tasks.compileKotlin)
    from(tasks.processResources) {
        eachFile {
            if (name == propertyFile) {
                file.writeText(propertyFileContent)
            }
        }
    }
    from(policy)
    from(libJSFolder) { into(libJS) }
    from(libWasmFolder) { into(libWasm) }
    from(libComposeWasmFolder) { into(libComposeWasm) }
    from(libJVMFolder) { into(libJVM) }
    from(compilerPluginsForJVMFolder) { into(compilerPluginsForJVM) }
    from(libComposeWasmCompilerPluginsFolder) { into(libComposeWasmCompilerPlugins) }
    into("lib") {
        from(configurations.compileClasspath) { exclude("tomcat-embed-*") }
    }
}

tasks.named<Copy>("processResources") {
    val archiveOperation = project.serviceOf<ArchiveOperations>()
    from(resourceDependency.map {
        archiveOperation.zipTree(it)
    }) {
        into("com/compiler/server")
    }
}

tasks.withType<Test> {
    with(rootProject.kotlinNodeJsEnvSpec) {
        dependsOn(rootProject.nodeJsSetupTaskProvider)
    }
    javaLauncher.set(javaToolchains.launcherFor {
        languageVersion.set(JavaLanguageVersion.of(17))
        vendor.set(JvmVendorSpec.AMAZON)
    })
    val executablePath = rootProject.kotlinNodeJsEnvSpec.executable.get()
    doFirst {
        this@withType.environment("kotlin.wasm.node.path", executablePath)
    }

    // We disable this on TeamCity, because we don't want to fail this test,
    // when compiler server's test run as a K2 user project.
    // But for our pull requests we still need to run this test, so we add it to our GitHub action.
    if (System.getenv("TEAMCITY_VERSION") != null) {
        filter {
            excludeTestsMatching("com.compiler.server.CompilerArguments*")
        }
    }
}
